-- l_strdraw.lua
--
-- a fucking terrible string drawer
-- by haya

local FRACUNIT = FRACUNIT
local FRACBITS = FRACBITS

local strdraw = {}

-- table of current fonts
strdraw.fonts = {}

-- print cos im lazy
-- taken from https://git.do.srb2.org/Rapidgame7/srb2utils/-/blob/main/TextWriter/Lua/writeText.lua
local function iprint(...)
	local argcount = select('#', ...)
	local argtbl = {...}
	local bigstr = ""
	for argix = 1,argcount do
		local arg = argtbl[argix]
		bigstr = $ .. tostring(arg) .. (argix ~= argcount and "\t" or "")
	end
	print("[strdraw]: " .. bigstr)
end

-- strdraw.forceSentinel(drawer v, int font)
--
-- Caches all valid glyphs for a font. Returns said font.
local function fuckCache(v, font, ascii)
	if ascii == 32 then return end
	
	local glyph = {}
	
	local patchname = string.format("%s%03d", font.prefix, ascii)
	if v.patchExists(patchname) then
		local patch = v.cachePatch(patchname)

		glyph.patch = patch
		glyph.width = patch.width
		glyph.height = patch.height
			
		font.maxHeight = ($ and (max($, patch.height)) or patch.height)
		font.maxWidth = ($ and (max($, patch.width)) or patch.width)
	end
	
	font.glyphs[ascii] = glyph
end

local function forceSentinel(v, font)
	-- store glyphs here
	local glyphs = {}
	
	-- find the font
	local fnt = strdraw.fonts[font]
	
	fnt.glyphs = {}
	
	-- We only really use 130 characters rest are skincolors
	for ascii = 0, 130 do 
		fuckCache(v, fnt, ascii)
	end
	
	if not fnt.monospace then
		fnt.monospace = fnt.maxWidth
	end
	
	if not fnt.spacewidth then
		fnt.spacewidth = fnt.monospace/2
	end
	
	return fnt
end

-- strdraw.register(string fontname, table params)
--
-- Registers a new font.
-- Parameters:
--
-- prefix: graphics prefix of the font patches (REQUIRED)
-- monospace: monospace width of font
-- spacewidth: width of a whitespace character. defaults to half of monospace width
-- sepxoffset: additional space between characters
local function register(fontname, params)
	-- oops!
	if not fontname then return end
	
	fontname = fontname:upper()
	params = $ or {}
	
	local fnt = {}
	
	fnt.monospace = params.monospace or 0
	fnt.spacewidth = params.spacewidth or 0
	fnt.prefix = params.prefix
	-- These are optional.
	fnt.sepxoffset = params.sepxoffset or 0
	fnt.sepyoffset = params.sepyoffset or 0
	
	-- done with everything
	local n = table.maxn(strdraw.fonts)+1
	strdraw.fonts[n] = fnt
	rawset(_G, "FONT_"..fontname, n)
	
	iprint("Registered font FONT_"..fontname.." (id: "..tostring(n)..") successfully!")
end

-- Once again taken from amperbee
local flagval = 0; local function flagup() flagval = $+1; return 1<<(flagval-1) end
-- flags!
rawset(_G, "SDF_INTPOS", flagup())
	-- multiplies coords by FRACUNIT.

-- strdraw.draw(drawer v, table params)
--
-- Draws your text. Shrimple as that!
-- Parameters:
-- 
-- x: x coordinate of text (REQUIRED)
-- y: y coordinate of text (REQUIRED
-- text: text string. can use SOC colors (REQUIRED, obviously)
-- font: FONT_ constant. generated by strdraw.register normally based on inputted font name (REQUIRED, obviously)
-- 
-- hscale, vscale: horizontal and vertical scale of text respectively
-- xoff, yoff: x and y offset of text respectively, for predraw functions
-- align: alignment of text, UDS/TextWriter style
--
--		-FU		0		FU
--		0		0.5		1
--		left	center	right
--
-- predraw: function called before text drawing.
--
--		function(data) 
--			-- "data" takes in same data as your actual draw parameters
--		end
--
-- sflags: flags specific to strdraw. see above flags
-- flags: draw flags to be passed directly to v.drawStretched
-- colormap: colormap for the text
local function draw(v, params)
	-- actual needed parameters
	local x, y, text, font = params.x, params.y, params.text, strdraw.fonts[params.font]
	if (x == nil or y == nil or text == nil or font == nil) then iprint("Are you dense and did not pass coordinates or text to a draw call?") return end
	
	-- optional
	local hscale, vscale = (params.hscale or FRACUNIT), (params.vscale or FRACUNIT)
	local sepx, sepy = font.sepxoffset, font.sepyoffset
	local offx, offy = (params.xoff or 0), (params.yoff or 0)
	local halign, valign = params.align, -FRACUNIT -- valign is unused for now...
	if params.align == nil then
		halign = -FRACUNIT
	end
	local predrawfunc = params.predraw or function(x, y, offx, offy, i, lineidx) end
	local sflags = params.sflags or 0
	local dflags = params.flags or 0
	local colormap = params.colormap or nil
	
	-- do this quickly
	if sflags & SDF_INTPOS then
		x, y = $1 << FRACBITS, $2 << FRACBITS
	end
	
	-- flag replacements
	if (dflags & V_FORCEUPPERCASE) then -- force uppercase
		text = text:upper()
	end
	
	-- split these into lines from line breaks
	local lines = {}
	
	for breaks in text:gmatch("[^\r\n]+") do
		table.insert(lines, breaks)
	end
	
	-- force sentinel if glyphs dont exist
	if not font.glyphs then forceSentinel(v, params.font) end
	
	local dta = {
		x = x, y = y, xoff = offx, yoff = offy,
		hscale = hscale, vscale = vscale,
		flags = dflags, colormap = colormap
	}
	
	-- Interate through the text blocks (alignment should always go last before char drawing)
	for lineidx = 1, #lines do
		-- reset x position again
		dta.x = x
		
		local line = lines[lineidx]
		local linewidth = 0
		local monomode = (dflags & V_MONOSPACE)
		
		-- calculate line width
		for i = 1, #line do
			local char = line:sub(i, i)
			local byte = char:byte()
			
			-- whitespace...
			if byte == 32 then
				linewidth = $ + font.spacewidth
				continue
			end
			
			if font.glyphs[byte] then
				local glyph = font.glyphs[byte]
				if glyph.width == nil then continue end -- HOW?????
				local width = (monomode and font.monospace or (glyph.width + sepx))
				linewidth = $ + width
			end
		end	
		
		linewidth = FixedMul($ << FRACBITS, dta.hscale)
		
		-- align shit now!
		local effhalign = (halign + FRACUNIT)/2
		local cx = -FixedDiv(FixedMul(linewidth, effhalign), FRACUNIT)
		
		-- actually start drawing
		for i = 1, #line do
			local char = line:sub(i, i)
			local byte = char:byte()
			
			-- SOC colors
			if (byte & 0xF0) == 0x80 then
				-- eyup.
				dta.colormap = v.getStringColormap((byte & 0x7f) << V_CHARCOLORSHIFT)
			end
			
			-- draw!
			if font.glyphs[byte] and font.glyphs[byte].patch then
				dta.curchar = i
				dta.curline = lineidx
				
				predrawfunc(dta)
				
				v.drawStretched(
					dta.x + dta.xoff + cx,
					dta.y + dta.yoff,
					dta.hscale, dta.vscale,
					font.glyphs[byte].patch, dta.flags, dta.colormap
				)
				
				dta.x = $ + FixedMul((monomode and font.monospace or (font.glyphs[byte].width + sepx))*FRACUNIT, dta.hscale)
			elseif byte == 32 then
				dta.x = $ + FixedMul(font.spacewidth*FRACUNIT, dta.hscale)
			end
		end	
		
		dta.y = $ + font.monospace*FRACUNIT
	end
end

strdraw.forceSentinel = forceSentinel
strdraw.register = register
strdraw.draw = draw

rawset(_G, "strdraw", strdraw)

-- EXAMPLE:

--[[

strdraw.register("FANCYMENU", {prefix = "MNUFN", monospace = 8, spacewidth = 4, sepxoffset = -2})

hud.add(function(v, p, c)
	strdraw.draw(v, {
		x = 20, y = 20,
		text = "Normal text but now its ".."\x84".."blue",
		font = FONT_FANCYMENU,
		sflags = SDF_INTPOS
	})
end)

--]]
